\documentclass[sigplan, anonymous, review]{acmart}

\usepackage{booktabs} % For formal tables
\usepackage[utf8x]{inputenc}
\usepackage{ucs}
\usepackage{graphicx}
\usepackage{amsmath,amsthm}
\usepackage{amssymb}
\usepackage{url}
\usepackage{stmaryrd}
\usepackage{ifpdf}
\ifpdf
  \usepackage{hyperref}
\fi
\usepackage{float}
\usepackage{proof}
%if False
\begin{code}
module paper where
\end{code}
%endif 

% Copyright
%\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}


% DOI
%\acmDOI{10.475/123_4}

% ISBN
%\acmISBN{123-4567-24-567/08/06}

%Conference
%\acmConference[HASKELL'17]{ACM Haskell Symposium}{July 2017}{El
 % Paso, Texas USA} 
\acmYear{2017}
\copyrightyear{2017}

%\acmPrice{15.00}

%\acmBadgeL[http://ctuning.org/ae/ppopp2016.html]{ae-logo}
%\acmBadgeR[http://ctuning.org/ae/ppopp2016.html]{ae-logo}


%include lhs2TeX.fmt
%include lhs2TeX.sty
%include polycode.fmt

\DeclareMathAlphabet{\mathkw}{OT1}{cmss}{bx}{n}
%subst keyword a = "\mathkw{" a "}"
%subst conid a = "\V{" a "}"
%subst varid a = "\V{" a "}"
%subst numeral a = "\C{" a "}"


\newcommand{\EvalCtxTran}[1]{\ensuremath{\mathbb{T}[#1]}}
\newcommand{\EvalCtxProc}[1]{\ensuremath{\mathbb{P}[#1]}}

\newtheorem{Lemma}{Lemma}
\newtheorem{Theorem}{Theorem}
\theoremstyle{definition}
\newtheorem{Example}{Example}


\usepackage{color}
\newcommand{\redFG}[1]{\textcolor[rgb]{0.6,0,0}{#1}}
\newcommand{\greenFG}[1]{\textcolor[rgb]{0,0.4,0}{#1}}
\newcommand{\blueFG}[1]{\textcolor[rgb]{0,0,0.8}{#1}}
\newcommand{\orangeFG}[1]{\textcolor[rgb]{0.8,0.4,0}{#1}}
\newcommand{\purpleFG}[1]{\textcolor[rgb]{0.4,0,0.4}{#1}}
\newcommand{\yellowFG}[1]{\textcolor{yellow}{#1}}
\newcommand{\brownFG}[1]{\textcolor[rgb]{0.5,0.2,0.2}{#1}}
\newcommand{\blackFG}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\whiteFG}[1]{\textcolor[rgb]{1,1,1}{#1}}
\newcommand{\yellowBG}[1]{\colorbox[rgb]{1,1,0.2}{#1}}
\newcommand{\brownBG}[1]{\colorbox[rgb]{1.0,0.7,0.4}{#1}}

\newcommand{\ColourStuff}{
  \newcommand{\red}{\redFG}
  \newcommand{\green}{\greenFG}
  \newcommand{\blue}{\blueFG}
  \newcommand{\orange}{\orangeFG}
  \newcommand{\purple}{\purpleFG}
  \newcommand{\yellow}{\yellowFG}
  \newcommand{\brown}{\brownFG}
  \newcommand{\black}{\blackFG}
  \newcommand{\white}{\whiteFG}
}

\newcommand{\MonochromeStuff}{
  \newcommand{\red}{\blackFG}
  \newcommand{\green}{\blackFG}
  \newcommand{\blue}{\blackFG}
  \newcommand{\orange}{\blackFG}
  \newcommand{\purple}{\blackFG}
  \newcommand{\yellow}{\blackFG}
  \newcommand{\brown}{\blackFG}
  \newcommand{\black}{\blackFG}
  \newcommand{\white}{\blackFG}
}

\ColourStuff

\newcommand{\D}[1]{\blue{\mathsf{#1}}}
\newcommand{\C}[1]{\red{\mathsf{#1}}}
\newcommand{\F}[1]{\green{\mathsf{#1}}}
\newcommand{\V}[1]{\purple{\mathit{#1}}}

%subst comment a = "\orange{\texttt{--" a "}}"

\newcommand{\TStep}[9]{\ensuremath{\langle  #2, #3, #4 \rangle
    \mapsto_{T_{#5}} \langle  #7, #8, #9 \rangle}}


\begin{document}


\title{Certified Bit-Coded Regular Expression Parsing}

\author{Rodrigo Ribeiro}
\affiliation{%
  \institution{Universidade Federal de Ouro Preto}
%  \streetaddress{P.O. Box 1212}
  \city{Ouro Preto} 
  \state{Minas Gerais --- Brazil} 
%  \postcode{43017-6221}
}
\email{rodrigo@decsi.ufop.br}

\author{André Du Bois}
\affiliation{%
  \institution{Universidade Federal de Pelotas}
%  \streetaddress{P.O. Box 1212}
  \city{Pelotas} 
  \state{Rio Grande do Sul --- Brazil} 
%  \postcode{43017-6221}
}
\email{dubois@inf.ufpel.br}

\begin{abstract}
We describe the formalization of a regular expression (RE) parsing
algorithm that produces a bit representation of its parse tree
in the dependently typed language Agda. The algorithm computes
bit-codes using Brzozowski derivatives and we prove that 
produced codes are equivalent to parse trees ensuring the 
soundness and completeness w.r.t an inductive RE semantics.
We include the certified algorithm in a tool, developed by us,
for regular expression based search in the style of the well 
known GNU grep. Practical experiments conducted with this tool 
are reported.
\end{abstract}
%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below. 
%
\begin{CCSXML}
<ccs2012>
 <concept>
  <concept_id>10010520.10010553.10010562</concept_id>
  <concept_desc>Computer systems organization~Embedded systems</concept_desc>
  <concept_significance>500</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010575.10010755</concept_id>
  <concept_desc>Computer systems organization~Redundancy</concept_desc>
  <concept_significance>300</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010553.10010554</concept_id>
  <concept_desc>Computer systems organization~Robotics</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
 <concept>
  <concept_id>10003033.10003083.10003095</concept_id>
  <concept_desc>Networks~Network reliability</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
</ccs2012>  
\end{CCSXML}

\ccsdesc[500]{Computer systems organization~Embedded systems}
\ccsdesc[300]{Computer systems organization~Redundancy}
\ccsdesc{Computer systems organization~Robotics}
\ccsdesc[100]{Networks~Network reliability}

% We no longer use \terms command
%\terms{Theory}

\keywords{Certified algorithms, regular expressions, bit-codes, dependent types}

\maketitle

%format . = "."
%format Set = "\D{Set}"
%format Set0 = Set "_{\D{0}}"
%format Set1 = Set "_{\D{1}}"
%format List = "\D{List}"
%format [] = "\C{\lbrack\:\rbrack}"
%format , = "\red{,}\,"
%format Nat = "\D{\mathbb{N}}"
%format zero = "\C{zero}"
%format succ = "\C{suc}"
%format id = "\F{id}"
%format o = "\F{\circ}"
%format Vec = "\D{Vec}"
%format :: = "\C{::}"
%format _::_ = "\C{\_::\_}"
\section{Introduction}\label{sec:intro}

Parsing is one of the most studied problems in computer science. 
It involves the process of checking if a string of symbols conforms to
a given set of rules. Usually, parsing is preceded by the 
specification of rules in a formalism (e.g. a grammar) and, also, either the
construction of data that makes evident which rules have been used to
conclude that the string of symbols can be obtained from it or, otherwise,
an indication of an error that represents the
fact that the string of symbols cannot be generated.

In this work we are interested in the parsing problem for regular
languages (RLs)~\cite{Hopcroft2000}, i.e.~languages that can be
recognized by (non-)deterministic finite automata and equivalent
formalisms. Regular expressions (REs) are an algebraic and compact way
of specifying RLs that are extensively used in lexical analyser
generators~\cite{Lesk1990} and string search utilities~\cite{Grep}.
Since such tools are widely used and parsing is pervasive in
computing, there is a growing interest on certified parsing
algorithms~\cite{FirsovU13,FirsovU14,Danielsson2010}.  
This interest is motivated by the recent development of dependently typed
languages. Such languages are powerful enough to express algorithmic
properties as types, that are automatically checked by a compiler.

In a previous work by one the authors~\cite{Lopes2016}, we described
the formalization of an algorithm for parsing RE's based on 
derivatives. RE derivatives were introduced by
Brzozowski~\cite{Brzozowski1964} as an alternative method to compute a
finite state machine that is equivalent to a given RE and to perform
RE-based parsing. Owens et. al~\cite{Owens2009} reintroduce this concept,
since ``derivatives have been lost in the sands of time'' until his work on
functional encoding of RE derivatives have renewed interest on its use
for parsing~\cite{Might2011,Fischer2010}. 

Nielsen et. al.~\cite{Nielsen2011} introduce algorithms to build compact representation of
RE parse trees as a sequence of bits, without explicitly constructing the parse tree first
and describe algorithms that simulate a finite state machine that output the required bit list. 
Sulzmann et. al.~\cite{SulzmannL14} designed a RE derivative-based algorithm
that incrementally builds a list of bits instead of a tree as parsing result. In both works
no machine checked proof was provided and some results claimed had counter-examples
found~\cite{AusafDU16}. This work aims to fill this gap. We provide fully 
certified proofs of Sulzmann et. al. derivative based parsing algorithm that 
produces a bit sequence equivalent to traditional parse trees and we use it 
in a RE based search tool that has been developed by us, using the dependently typed language
Agda~\cite{Norell2009}.

More specifically, our contributions are:
\begin{itemize}
  \item A formalization of bit-codes for RE parse trees, as presented in~\cite{Nielsen2011},
        and machine checkable proof ofs their properties.
  \item A formalization of bit-annotated regular expressions (BRE), its semantics 
        and its soundness and completeness theorems w.r.t. standard RE semantics. 
        We also relate produced bit sequences and RE semantics proving how they 
        are related to each other.
  \item A formalization of Brzozowski derivatives for BRE and its soundness and
        completeness theorem w.r.t to BRE semantics.
  \item We build certified decision procedures for matching prefixes and subtrings
        of BRE.
\end{itemize}

The rest of this paper is organized as follows. Section~\ref{sec:agda}
presents a brief introduction to Agda. Section~\ref{sec:regexp}
describes the encoding of REs, its parse trees and their representation as 
bit-codes. In Section~\ref{sec:bitregex} we present bit-annotated REs, 
its semantics and their relation with REs. In Section~\ref{sec:deriv} 
we formalize a variant of Brzozowski derivatives for bit-annotated REs, its 
properties and describe how to build a correct parsing algorithm from them. 
Section~\ref{sec:exp} comments on the use of the certified algorithm to build a tool for
RE-based search and present some experiments with this tool. Related
work is discussed on Section~\ref{sec:related}. Section~\ref{sec:conclusion} concludes.

All the source code in this article has been formalized in Agda
version 2.5.2 using Standard Library 0.13, but
we do not present every detail. Proofs of some properties result in
functions with a long pattern matching structure, that would distract
the reader from understanding the high-level structure of the
formalization. In such situations we give just proof sketches and point
out where all details can be found in the source code.

All source code produced including
the \LaTeX~ source of this article, are avaliable
on-line~\cite{regex-rep}.


\section{An Overview of Agda}\label{sec:agda}

%format String = "\D{String}"
%format Bool = "\D{Bool}"
%format forall = "\D{\forall}"
Agda is a dependently-typed functional programming language based on
Martin-L\"of intuitionistic type theory~\cite{Lof98}.  Function types
and an infinite hierarchy of types of types, |Set l|, where |l| is a
natural number, are built-in. Everything else is a user-defined
type. The type |Set|, also known as |Set0|, is the type of all
``small'' types, such as |Bool|, |String| and |List Bool|.  The type
|Set1| is the type of |Set| and ``others like it'', such as |Set ->
Bool|, |String -> Set|, and |Set -> Set|. We have that |Set l| is an
element of the type |Set (l+1)|, for every $l \geq 0$. This
stratification of types is used to keep Agda consistent as a logical
theory~\cite{Sorensen2006}.

An ordinary (non-dependent) function type is written |A -> B| and a
dependent one is written |(x : A) -> B|, where type |B| depends on
|x|, or |forall (x : A) -> B|. Agda allows the definition of \emph{implicit
parameters}, i.e.  parameters whose value can be infered from the
context, by surrounding them in curly braces: |forall {x : A} -> B|. To
avoid clutter, we'll omit implicit arguments from the source code
presentation. The reader can safely assume that every free variable in
a type is an implicity parameter.

As an example of Agda code, consider the the following data type of
length-indexed lists, also known as vectors.

\begin{code}
  data Nat : Set where
    zero : Nat
    succ : Nat -> Nat

  data Vec (A : Set) : Nat -> Set where
    []  : Vec A zero
    _::_ : forall {n} -> A -> Vec A n -> Vec A (succ n)
\end{code}
%format head = "\F{head}"
Constructor |[]| builds empty vectors. The cons-operator (|_::_|)
inserts a new element in front of a vector of $n$ elements (of type
|Vec A n|) and returns a value of type |Vec A (succ n)|. The
|Vec| datatype is an example of a dependent type, i.e. a type
that uses a value (that denotes its length). The usefulness of
dependent types can be illustrated with the definition of a safe list
head function: |head| can be defined to accept only non-empty
vectors, i.e.~values of type |Vec A (succ n)|.
\begin{spec}
  head : Vec A (succ n) -> A
  head (x :: xs) = x
\end{spec}
In |head|'s definition, constructor |[]| is not used. The
Agda type-checker can figure out, from |head|'s parameter type,
that argument |[]| to |head| is not type-correct.

%format _==_ = "\D{" == "}"
%format == = "\D{\equiv}"
%format refl = "\C{refl}"
%format proj₁ = "\F{\pi_1}"
%format proj₂ = "\F{\pi_2}"

Thanks to the propositions-as-types principle\footnote{Also known as
  Curry-Howard ``isomorphism''~\cite{Sorensen2006}.} we can interpret
types as logical formulas and terms as proofs. An example is the
representation of equality as the following Agda type:

\begin{code}
  data _==_ {l}{A : Set l}(x : A) : A -> Set where
    refl : x == x
\end{code}

%format not = "\F{\neg}"
%format Dec = "\D{Dec}"
%format yes = "\C{yes}"
%format no  = "\C{no}"
%format Even = "\C{Even}"
%format Odd = "\C{Odd}"
%format Parity = "\D{Parity}"
%format parity = "\F{parity}"
%format natToBin = "\F{natToBin}"
%format false = "\C{false}"
%format true = "\C{true}"
%format + = "\F{+}"
%format ++ = "\F{++}"
%format Bot = "\D{\bot}" 
This type is called propositional equality. It defines that there is
a unique evidence for equality, constructor |refl| (for reflexivity),
that asserts that the only value equal to |x| is itself. Given a type |P|,
type |Dec P| is used to build proofs that |P| is a
decidable proposition, i.e.~that either |P| or not |P|
holds. The decidable proposition type is defined as:
\begin{spec}
  data Dec (P : Set) : Set where
     yes : P -> Dec P
     no  : not P -> Dec p
\end{spec}
Constructor |yes| stores a proof that property |P| holds
and constructor |no| an evidence that such proof is impossible. Some functions
used in our formalization use this type. The type |¬ P| is an
abbreviation for |P -> Bot|, where
|Bot| is a data type with no constructors (i.e.~a data
type for which it is not possible to construct a value, which corresponds to
a false proposition).

%format exts = "\D{\exists}"
%format Sig = "\D{\Sigma}"
%format lmax = "\F{\sqcup}"
%format _,_ = "\C{\_,\_}"
A useful data type in dependently typed languages is the so-called dependent-product,
or $\Sigma$-types, that generalizes cartesian products. A possible definition of dependent products 
in Agda is as follows:
\begin{spec}
data Sig {a b}(A : Set a)(B : A -> Set b) : Set (a lmax b) where
  _,_ : (x : A) -> B x -> Sig A B
\end{spec}
A value of type |Sig A B| corresponds to a pair formed by a value |x| of type |A| and 
a value of type |B x|. Note that second component type depends on the value of first 
component. Under proposition-as-types interpretation, dependent products are equivalent
to existential quantification, since values of dependent products are formed by a value |x : A|,
which can be understood as a witness of existential quantification, and a value |B x|, which
represents the proof that |x| holds for |B|. Agda standard library represents existential
quantification a dependent product in which the first component is an implicit parameter:
\begin{spec}
exts : forall {a b} {A : Set a} -> (A -> Set b) -> Set (a lmax b)
exts = Sig _
\end{spec}
In some functions involving dependent products we use wilcards ``\_'' to avoid the need to
explicitly write their values, since Agda type checker can infer them.
Finally, we represent projections on dependent products as |proj₁| and |proj₂| which recover the first
and second component of product types, repectively.

Dependently typed pattern matching is built by using the so-called
|with| construct, that allows for matching intermediate
values~\cite{McBride2004}. If the matched value has a dependent type,
then its result can affect the form of other values. For example,
consider the following code that defines a type for natural number
parity. If the natural number is even, it can be represented as the
sum of two equal natural numbers; if it is odd, it is equal to one
plus the sum of two equal values. Pattern matching on a value of
|Parity n| allows to discover if $n = j + j$ or $n = S (k + k)$,
for some $j$ and $k$ in each branch of |with|.  Note that the
value of $n$ is specialized accordingly, using information ``learned''
by the type-checker.
\begin{spec}
data Parity : Nat -> Set where
   Even : forall {n : Nat} -> Parity (n + n)
   Odd  : forall {n : Nat} -> Parity (S (n + n))

parity : (n : Nat) -> Parity n
parity = -- definition omitted

natToBin : Nat -> List Bool
natToBin zero = []
natToBin k with (parity k)
   natToBin (j + j)     | Even = false :: natToBin j
   natToBin (succ (j + j)) | Odd  = true  :: natToBin j
\end{spec}

For further information about Agda, see~\cite{Norell2009,Stump16}.


\section{Regular Expressions}\label{sec:regexp}

\subsection{Standard Regular Expressions}

%format Char = "\D{Char}"

Regular expressions are defined with respect to a given
alphabet. Formally, the following context-free
grammar defines RE syntax:
\[
e ::= \emptyset\,\mid\,\epsilon\,\mid\,a\,\mid\,e\,e\,\mid\,e+e\,\mid\,e^{\star}
\]
where $a$ is any symbol from the underlying alphabet.
In our Agda formalization, we represent alphabet symbols using type |Char|.

%format Regex = "\D{Regex}"
%format Eps = "\C{\epsilon}"
%format Emp = "\C{\emptyset}"
%format # = "\C{\$}"
%format * = "\C{\bullet}"
%format + = "\C{+}"
%format ⋆ = "\C{\star}"
%format #_ = "\C{\$\_}"
%format _*_ = "\C{\_\bullet\_}"
%format _+_ = "\C{\_+\_}"
%format _** = "\C{\_\star}"
%format ** = "\C{\star}"


Datatype |Regex| encodes RE syntax.

\begin{spec}
  data Regex : Set where
    Emp : Regex
    Eps : Regex
    #_  : Char -> Regex
    _*_ : Regex -> Regex -> Regex
    _+_ : Regex -> Regex -> Regex
    _**  : Regex -> Regex
\end{spec}
Constructors |Emp| and |Eps| denote respectively the
empty language ($\emptyset$) and the empty string ($\epsilon$). Alphabet
symbols are constructed by using the |#| constructor. Bigger REs are
built using concatenation (|*|), union (|+|) and
Kleene star (|**|). 

%format _<<-[[_]] = "\D{\_\in\llbracket\_\rrbracket}"
%format <<-[[ = "\D{\in\llbracket}"
%format ]] = "\D{\rrbracket}"
%format ++ = "\F{++}"
%format => = "\C{\Rightarrow}"
%format _+L_ = "\C{\_+L\_}"
%format _+R_ = "\C{\_+R\_}"
%format +L = "\C{+L}"
%format +R = "\C{+R}"

The following datatype defines RE semantics inductively.

\begin{spec}
  data _<<-[[_]] : List Char -> Regex -> Set where
    Eps : [] <<-[[ Eps ]]
    #_  : (c : Char) -> # c <<-[[ # c ]]
    _*_ : xs <<-[[ l ]]  -> ys <<-[[ r ]]  -> (xs ++ ys) <<-[[ l * r ]]
    _+L_ : (r : Regex) -> xs <<-[[ l ]] -> xs <<-[[ l + r ]]
    _+R_ : (l : Regex) -> xs <<-[[ r ]] -> xs <<-[[ l + r ]]
    _** : xs <<-[[ Eps + (e ∙ e ⋆) ]] -> xs <<-[[ e ⋆ ]]
\end{spec}

Constructor |Eps| states that the empty string (denoted by the empty list |[]|)
is in the language of RE |Eps|.

For any single character |a|, the singleton
string |[ a ]| is in the RL
for |# a|. Given membership proofs for REs
|l| and |r|, |xs <<-[[ l ]]| and |ys <<-[[ r ]]|, constructor
|_*_| can be used to build a proof
for the concatenation of these REs.  Constructor
|_+L_| (|_+R_|) creates a membership proof
for |l + r| from a proof from |l| (|r|). Semantics for Kleene star
is built using the following well known equivalence of REs: $e^\star
= \epsilon + e\,e^\star$. Notice that we use the same constructor names both in RE syntax and 
in its semantics. Agda allows the overloading of data-constructors names.

Several inversion lemmas about RE parsing relation are necessary for
derivative-based parsing formalization. They consist of
pattern-matching on proofs of
\ensuremath{\D{\_\in\llbracket\_\rrbracket}} and are omitted for
brevity.

%format Tree = "\D{Tree}"
%format inl = "\C{inl}"
%format inr = "\C{inr}"
%format star[] = "\C{star[]}"
%format star-:: = "\C{star-::}"
%format flat = "\F{flat}"
%format unflat = "\F{unflat}"
%format exts = "\C{\exists}"

One way to look at RE parsing is to intepret its parse trees as terms
whose type is an RE~\cite{Nielsen2011,FrischC04}. To ensure the consistency 
between a tree and its RE type, we use an indexed data-type, an usual approach 
in dependently typed languages~\cite{Norell2009}.
\begin{spec}
  data Tree : Regex -> Set where
    Eps : Tree Eps
    #_ : (c : Char) -> Tree (# c)
    inl : forall (r : Regex)(tl : Tree l) -> Tree (l + r)
    inr : forall (l : Regex)(tr : Tree r) -> Tree (l + r)
    _*_ : forall (tl : Tree l)(tr : Tree r) -> Tree (l * r)
    star[] : Tree (l **)
    star-:: : Tree l -> Tree (l **) -> Tree (l **)
\end{spec}
Each constructor of |Tree| specifies how to build a parse tree
for an RE. As an example, value |inl Eps ((# 'a') * (# 'b')| denotes
a parse tree for RE $ab + \epsilon$ and string |"ab"|.

The relation between RE semantics and its parse trees are formalized by
functions |flat| and |unflat|. The |flat| function builds a membership proof from a given parse tree by
recursion on its structure. At each step, |flat| returns a pair formed
by a string and its RE membership proof. Matched strings can be recovered from parse trees
by concatenating values in its leafs (that would be the empty string or a single character).
\begin{spec}
  flat : Tree e -> exts (\ xs -> xs <<-[[ e ]])
  flat Eps = [] , Eps
  flat (# c) =  [ c ] , (# c)
  flat (inl r t) with flat t
  ...| xs , prf = _ , r +L prf
  flat (inr l t) with flat t
  ...| xs , prf = _ , l +R prf
  flat (t * t') with flat t | flat t'
  ...| xs , prf | ys , prf' = , (prf * prf')
  flat star[] = [] , (_ +L Eps) **
  flat (star-:: t t') with flat t | flat t'
  ...| xs , prf | ys , prf' = , (_ +R (prf * prf')) **
\end{spec}
Note that our definition of |flat| ensures, by construction, that the string produced
by a parse tree is in its RE language. Such property is stated in Nielsen et. al. paper
as a theorem (cf. Theorem 2.1~\cite{Nielsen2011}).

Function |unflat| builds parse trees from RE membership proofs straightforwardly.
\begin{spec}
  unflat : xs <<-[[ e ]] -> Tree e
  unflat Eps = Eps
  unflat (# c) = # c
  unflat (prf * prf') = unflat prf * unflat prf'
  unflat (r +L prf) = inl r (unflat prf)
  unflat (l +R prf) = inr l (unflat prf)
  unflat ((_ +L Eps) **) = star[]
  unflat ((_ +R (prf * prf')) **) = star-:: (unflat prf) (unflat prf')
\end{spec}
The next lemmas state that functions |flat| and |unflat| are inverses.
\begin{Lemma}
Let |e| be a RE and |t : Tree e| a parse tree. Then |unflat (proj₂ (flat t)) == t|.
\end{Lemma}
\begin{proof}
  Structural induction on |t|.
\end{proof}
\begin{Lemma}
Let |xs| be a string and |e| a RE s.t. |xs <<-[[ e ]]|. Then |flat (unflat prf) == (xs , prf)|.
\end{Lemma}
\begin{proof}
  Structurural induction on the derivation of |xs <<-[[ e ]]|.
\end{proof}

\subsection{Bit-codes for RE Parse Trees}\label{sec:bitregex}

%format IsBitCodeOf = "\D{IsCode}"
%format _IsBitCodeOf_ = "\D{\_IsCode\_}"
%format Bit = "\D{Bit}"
%format zero = "\C{0_b}"
%format one = "\C{1_b}"
%format inl = "\C{inl}"
%format inr = "\C{inr}"
%format star[] = "\C{star[]}"
%format star-:: = "\C{star-::}"
We follow the encoding of Nielsen et. al.~\cite{Nielsen2011} that use bit marks to
register which branch was chose in a parse tree for a union operator, |+|, and the beginning 
and end of matchs done by a Kleene star. We represent bit sequences using lists whose elements 
are of type |Bit|. 
\begin{spec}
data Bit : Set where
  zero one : Bit
\end{spec}
Not every bit list corresponds to a valid parse tree. Data type |IsBitCodeOf| represents
an inductive predicate that holds when a bit list |bs| denotes a valid parse tree for some
RE |e|.
\begin{spec}
    data _IsBitCodeOf_ : List Bit -> Regex -> Set where
      Eps : [] IsBitCodeOf Eps
      #_ : (c : Char) -> [] IsBitCodeOf (# c)
      inl : xs IsBitCodeOf l -> (zero :: xs) IsBitCodeOf (l + r)
      inr : xs IsBitCodeOf r -> (one :: xs) IsBitCodeOf (l + r)
      _*_ : xs IsBitCodeOf l -> ys IsBitCodeOf r -> (xs ++ ys) IsBitCodeOf (l * r)
      star[] : [ one ] IsBitCodeOf (l **)
      star-:: : xs IsBitCodeOf l -> xss IsBitCodeOf (l **) -> 
                (zero :: xs ++ xss) IsBitCodeOf (l **)
\end{spec}
The empty string and single character RE are both represented by empty bit lists. 
Codes for RE |l * r| are built by concatenating codes of |l| and |r|. In RE union operator, |+|, 
the bit |zero| marks that parse tree for |l + r| is built from |l|'s and bit |one| that it is
built from |r|'s. For Kleene star, we use bit |one| to denote the parse tree for the empty string and
bit |zero| to begin matchings of |l| in a parse tree for |l **|.
 
%format decode' = "\F{decode}"
%format code = "\F{code}"

Function |code| builds a bit representation for a parse tree 
together with a proof that the produced bit string is a valid
tree representation.
\begin{spec}
  code : Tree e -> exts (\ bs -> bs IsBitCodeOf e)
  code Eps = [] , Eps
  code (# c) = [] , (# c)
  code (inl r t) with code t
  ...| ys , pr = zero :: ys , inl r pr
  code (inr l t) with code t
  ...| ys , pr = one :: ys , inr l pr
  code (t ∙ t') with code t | code t'
  ...| xs , pr | ys , pr' = xs ++ ys , pr ∙ pr' 
  code star[] = one :: [] , star[]
  code (star-:: t ts) with code t | code ts
  ...| xs , pr | xss , prs = (zero :: xs ++ xss) , star-:: pr prs
\end{spec}
Next we present function |decode'| which generate a parse tree
from its correspondent bit code.
\begin{spec}
  decode' : exts (\ bs -> bs IsBitCodeOf e) -> Tree e
  decode' (_ , Eps) = Eps
  decode' (_ , (# c)) = # c
  decode' (_ , (inl r pr)) = inl r (decode' (_ , pr))
  decode' (_ , (inr l pr)) = inr l (decode' (_ , pr))
  decode' (_ , (pr ∙ pr')) with decode' (_ , pr) | decode' (_ , pr')
  ...| bs1 , pr1 | bs2 , pr2 = pr1 * pr2
  decode' star[] = (_ +L Eps) **
  decode' (star-:: pr pr') with decode' (_ ,pr) | decode' (_ ,pr') 
  ...| pr1 | pr2 =  (_ +R (pr1 * pr2)) **
\end{spec}

As one might expect, decoding a bit sequence produced by |code| function 
will produce the original parse tree.

\begin{Theorem}
   Let |t : Tree e| for some RE |e|. Then, |decode' (code t) == t|.
\end{Theorem}
\begin{proof}
   Structurual induction over |t|. 
\end{proof}

\begin{Example}
As an example of bit coded parse tree, consider the string |"ab"| which is in
$(a + b)^\star$ language. The parse tree for |"ab"| is:
\begin{spec}
  star-:: (inl _ (# 'a')) 
          (star-:: (inr _ (# 'b'))
                   star[])
\end{spec}
and its bit code is |[ zero , zero , zero , one , one ]|. The first occurrence of |zero|
starts a bit sequence for |star-::| constructor. Second occurrence of |zero| represents
the parse tree for left component of $a + b$ and next occurrence of |zero| also denotes
|star-::|. The first occurrence of |one| marks a parse tree for right component of $a + b$ 
and the last symbol |one| finishes the bit code for Kleene star operator.
\end{Example}

Building bit codes from parse trees does not present any advantage, since after building parse trees
we will need to traverse them in order to generate codes. A better strategy is to incrementally build
bit-codes while parsing a given RE. In next sections, we describe the formalization of this approach, due to 
Sulzmann et. al.~\cite{SulzmannL14}.

\subsection{Bit-annotated Regular Expressions}

%format BitRegex = "\D{BitRegex}"
%format empty = "\C{empty}"
%format eps = "\C{eps}"
%format char = "\C{char}"
%format choice = "\C{choice}"
%format cat = "\C{cat}"
%format star = "\C{star}"
%format internalize = "\F{internalize}"
%format fuse = "\F{fuse}"
%format erase = "\F{erase}"
Bit-annotated regular expressions are defined by the following grammar, where
variable $bs$ denotes an arbitrary sequence of bits.

\[
ri ::= \emptyset\,\mid\,bs\rhd\epsilon\,\mid\,bs\rhd a\,\mid\,bs\rhd ri\,ri\,\mid\,bs\rhd ri+ri\,\mid\,bs\rhd ri^{\star}   
\]
Intuitively, BRE just attach a list of bits $bs$ to every non-empty regular expression. 
Type |BitRegex| define the syntax of BRE, which has an obvious interpretation.
\begin{spec}
data BitRegex : Set where
  empty  : BitRegex
  eps    : List Bit -> BitRegex
  char   : List Bit -> (c : Char) -> BitRegex
  choice : List Bit -> BitRegex -> BitRegex -> BitRegex
  cat    : List Bit -> BitRegex -> BitRegex -> BitRegex
  star   : List Bit -> BitRegex -> BitRegex
\end{spec}
Conversion between |Regex| and |BitRegex| types are made by functions |internalize| and |erase|.  
First, we define an auxiliar function, |fuse|, which  attachs a bit code to top-most position of an BRE.
\begin{spec}
    fuse : List Bit -> BitRegex -> BitRegex
    fuse bs empty = empty
    fuse bs (eps x) = eps (bs ++ x)
    fuse bs (char x c) = char (bs ++ x) c
    fuse bs (choice x e e') = choice (bs ++ x) e e'
    fuse bs (cat x e e') = cat (bs ++ x) e e'
    fuse bs (star x e) = star (bs ++ x) e
\end{spec}
Function |internalize| converts a standard RE into BRE by inserting empty bit lists on it.
\begin{spec}
    internalize : Regex -> BitRegex
    internalize Emp = empty
    internalize Eps = eps [] 
    internalize (# x) = char [] x
    internalize (e * e') = cat [] (internalize e) (internalize e')
    internalize (e + e') = choice [] (fuse [ zero ] (internalize e)) 
                                     (fuse [ one ] (internalize e'))
    internalize (e **) = star [] (internalize e)
\end{spec}
Function |erase| is straightforwardly defined by recursion.
\begin{spec}
    erase : BitRegex -> Regex
    erase empty = Emp
    erase (eps x) = Eps
    erase (char x c) = # c
    erase (choice x e e') = erase e + (erase e')
    erase (cat x e e') = erase e * (erase e')
    erase (star x e) = (erase e) **
\end{spec}
The relation between these functions is expressed by the following lemmas.
\begin{Lemma}\label{erase-fuse-lemma}
Let |e : Regex| and |bs : List Bit|. Then:\\  |erase (fuse bs (internalize e)) == e|.
\end{Lemma}
\begin{proof}
   Structural induction on |e|.
\end{proof}
\begin{Lemma}
Let |e : Regex|. Then, |erase (internalize e) == e|
\end{Lemma}
\begin{proof}
  Structural induction on |e| using Lemma~\ref{erase-fuse-lemma}.
\end{proof}
%format _<<-<<_>> = "\D{\_\in\langle\_\rangle}"
%format <<-<< = "\D{\in\langle}"
%format >> = "\D{\rangle}"
Next, we define an alternative inductive semantics for BRE and show that it is 
sound and complete w.r.t. standard RE semantics. A value of type |xs <<-<< e >>| states
that string |xs| is in the language denoted by |BitRegex| |e|.
\begin{spec}
data _<<-<<_>> : List Char -> BitRegex -> Set where
  eps  : (bs : List Bit) -> [] <<-<< eps bs >>
  char : (bs : List Bit)(c : Char) -> [ c ] <<-<< char bs c >>
  inl  : (r : BitRegex) bs ->  xs <<-<< l >> -> xs <<-<< choice bs l r >>
  inr  : (l : BitRegex) bs ->  xs <<-<< r >> -> xs <<-<< choice bs l r >>
  cat  : (bs : List Bit) -> xs <<-<< l >> -> ys <<-<< r >> -> 
         (xs ++ ys) <<-<< cat bs l r >>
  star[] : (bs : List Bit) -> [] <<-<< star bs l >>
  star-:: : bs -> (x :: xs) <<-<< l >> -> xss <<-<< star [] l >> -> 
            (x :: xs ++ xss) <<-<< star bs l >>
\end{spec}
Relation between |BitRegex| and |Regex| semantic are specified by
the following theorem.
\begin{Theorem}
Let |e : Regex| and |xs : List Char|. Then, |xs <<-[[ e ]]|, if and only if,
|xs <<-<< internalize e >>|.
\end{Theorem}
\begin{proof}$\,$\\
$(\to)$: Structural induction on |xs <<-[[ e ]]|.\\
$(\leftarrow)$: Structural induction on |e|.
\end{proof}

\section{Derivatives and Parsing}\label{sec:deriv}

Formally, the derivative of a formal language $L\subseteq
\Sigma^\star$ with respect to a symbol $a\in\Sigma$ is the language
formed by suffixes of $L$ words without the prefix $a$.

An algorithm for computing the derivative of a language represented by
a RE as another RE is due to Brzozowski~\cite{Brzozowski1964}. It
relies on a function (called $\nu$) that determines if some RE accepts
or not the empty string (by returning |Eps| or |∅|, respectively):
\[
    \begin{array}{lcl}
         \nu(\emptyset) & = & \emptyset \\
         \nu(\epsilon)    & = & \epsilon \\
         \nu(a)                & = & \emptyset \\
         \nu(e\,e')           & = & \left\{
                                                 \begin{array}{ll}
                                                      \epsilon &
                                                                 \text{if
                                                                 }\nu(e)
                                                                 =
                                                                 \nu(e')
                                                                 =
                                                                 \epsilon
                                                   \\
                                                   \emptyset &
                                                               \text{otherwise}
                                                 \end{array}
                                             \right. \\
         \nu(e + e')  & = & \left\{
                                         \begin{array}{ll}
                                              \epsilon & \text{if
                                                         }\nu(e) =
                                                         \epsilon
                                                         \text{ or
                                                         }\nu(e') =
                                                         \epsilon \\
                                              \emptyset & \text{otherwise}
                                         \end{array}
                                      \right. \\
         \nu(e^\star) & = & \epsilon
    \end{array}
\]
%format nuu[_] = "\F{\nu[\_]}"
%format nuu[ = "\F{\nu[ }"
%format ]> = "\F{]}"
%format ∈+-invert = "\F{∈+-invert}"
%format []∈∙-invert = "\F{[]∈∙-invert}"
Decidability of $\nu(e)$ is proved by function |nuu[ e ]|,
which is defined by induction over the structure of the input BRE
|e| and returns a proof that the empty string is accepted or
not, using Agda type of decidable propositions, |Dec P|.
\begin{spec}
  nuu[_] : forall (e : BitRegex) -> Dec ( [] <<-<< e >>)
  nuu[ empty ]> = no (\ ())
  nuu[ eps bs ]> = yes eps
  nuu[ char bs x ]> = no (\ ())
  nuu[ cat bs e e' ]> with nuu[ e ]> | nuu[ e' ]>
  nuu[ cat bs e e' ]> | yes pr | (yes pr1) 
      = yes (cat bs pr pr1)
  nuu[ cat bs e e' ]> | yes pr | (no ¬pr1) 
      = no (¬pr1 ∘ proj₂ ∘ []∈∙-invert)
  nuu[ cat bs e e' ]> | no ¬pr | pr1 
      = no (¬pr ∘ proj₁ ∘ []∈∙-invert)
  nuu[ choice bs e e' ]> with nuu[ e ]> | nuu[ e' ]>
  nuu[ choice bs e e' ]> | yes pr | pr1 = yes (e' +L pr)
  nuu[ choice bs e e' ]> | no ¬pr | (yes pr1) = yes (e +R pr1)
  nuu[ choice bs e e' ]> | no ¬pr | (no ¬pr1) 
      = no ( [ ¬pr , ¬pr1 ] ∘ ∈+-invert)
  nuu[ star bs e ]> = yes star[]
\end{spec}
Function |nuu[ e ]| is an immediate transalation of $\nu(e)$, as
defined by Brzozowski, to Agda code and it 
uses several inversion lemmas about
BRE semantics. Lemma |[]∈∙-invert| states that if the empty string
is in the language of |cat bs l r| (where |l| and |r| are arbitrary BRE's)
then the empty string belongs to |l| and |r|'s languages.
Lemma |∈+-invert| is defined similarly for choice.

\subsection{Derivatives for Bit-annotated REs its Properties}

%format ∂[_,_] = "\F{∂[\_,\_]}"
%format ∂[ = "\F{∂[}"
%format =?= = "\F{\overset{?}{=}}"
%format mkEps = "\F{mkEps}"

Following Sulzmann~\cite{SulzmannL14},  we define
a function |mkEps| that builds the bit code for a 
nullable BRE, (i.e. a BRE s.t. |[] <<-<< e >>|).
\begin{spec}
    mkEps : [] <<-<< t >> -> List Bit
    mkEps (eps bs) = bs
    mkEps (inl br bs pr) = bs ++ mkEps pr
    mkEps (inr bl bs pr) = bs ++ mkEps pr
    mkEps (cat bs pr pr') = bs ++ mkEps pr ++ mkEps pr'
    mkEps (star[] bs) = bs ++ [ one ]
    mkEps (star-:: bs pr pr' x) = bs ++ [ one ]
\end{spec}
Next we define the derivative operation on BRE in Agda. The difference betwen this definition 
and standard Brzozowski derivatives~\cite{Brzozowski1964} is that the former inserts parse tree
information in terms of bit annotations. For example, consider |cat bs l r| where |[] <<-<< l >>|, additional
parse information is built from nullability test result using functions |mkEps| and |fuse|.
For Kleene star operation we record the start of a new iteration fusing |[ zero ]| and we mark a start of a
new matching interation by attaching the empty list in |star [] e|.

\begin{spec}
  ∂[_,_] : BitRegex -> Char -> BitRegex
  ∂[ empty , c ]> = empty
  ∂[ eps bs , c ]> = eps bs
  ∂[ char bs c , c' ]> with c =?= c'
  ...| yes refl = eps bs
  ...| no prf = empty
  ∂[ cat bs e e' , c ]> with nuu[ e ]>
  ∂[ cat bs e e' , c ]> | yes pr 
       = choice bs (cat bs ∂[ e , c ]> e') (fuse (mkEps pr) ∂[ e' , c ]>)
  ∂[ cat bs e e' , c ]> | no ¬pr = cat bs ∂[ e , c ]> e'
  ∂[ choice bs e e' , c ]> = choice bs (∂[ e , c ]>) (∂[ e' , c ]>)
  ∂[ star bs e , c ]> 
     = cat bs (fuse [ zero ] ∂[ e , c ]>) (star [] e)
\end{spec}

From this definition we prove the following important properties of
the derivative operation. Soundness of |∂[_,_]| ensures that if a
string |xs| is in the language of |∂[ e , x ]> |, then
|(x :: xs) <<-<< e >>| holds. Completeness ensures that the
other direction of implication holds.

\begin{Theorem}[Derivative operation soundness]\label{derivsound}
For all BREs |e|, all strings |xs| and all symbols |x|, if
| xs <<-<< ∂[ e , x ]> >> | holds then |(x :: xs) <<-<< e >> | holds.
\end{Theorem}
\begin{proof}
  By induction on the structure of |e|.
\end{proof}

\begin{Theorem}[Derivative operation completeness]\label{derivcomplete}
For all BREs |e|, all strings |xs| and all symbols |x|, if
|(x :: xs) <<-<< e >> | holds then | xs <<-<< ∂[ e , x ]> >> | holds.
\end{Theorem}
\begin{proof}
  By induction on the structure of |e|.
\end{proof}

\subsection{Parsing}

RE parsing involves determining which prefixes and substrings of the
input string match a given RE. For this, we define datatypes that
represent the fact that a given BRE matches a prefix or a substring of
a given string.

%format IsPrefix = "\D{IsPrefix}"
%format Prefix = "\C{Prefix}"
%format IsSubstring = "\D{IsSubstr}"
%format Substring = "\C{Substr}"
%format ¬IsPrefix = "\F{¬IsPrefix}"
%format ¬IsPrefix-:: = "\F{¬IsPrefix-::}"
%format ¬IsSubstring = "\F{¬IsSubstring}"
%format ¬IsSubstring-:: = "\F{¬IsSubstring-::}"

We say that BRE |e| matches a prefix of string |xs| if there exist
strings |ys| and |zs| such that |xs == ys ++ zs| and |ys <<-<< e >>|. 
Definition of |IsPrefix| datatype encode this concept. Datatype
|IsSubstring| specifies when a BRE |e| matches a substring in |xs|:
there must exist strings |ys|, |zs| and |ws| such that |xs == ys ++ zs
++ ws| and |zs <<-<< e >> | hold.

\begin{spec}
  data IsPrefix (xs : List Char)(e : BitRegex) : Set where
    Prefix : xs == ys ++ zs -> ys <<-<< e >> -> IsPrefix xs e
    
  data IsSubstring (xs : List Char)(e : BitRegex) : Set where
    Substring :  xs == ys ++ zs ++ ws -> zs <<-<< e >> -> IsSubstring xs e
\end{spec}
Using these datatypes we can define the following relevant properties
of prefixes and substrings.

\begin{Lemma}[Lemma |¬IsPrefix|]\label{pref1}
  For all BREs |e|, if |[] <<-<< e >>| does not hold then neither does |IsPrefix [] e|. 
\end{Lemma}
\begin{proof}
  Immediate from the definition of |IsPrefix| and properties of list concatenation.
\end{proof}

\begin{Lemma}[Lemma |¬IsPrefix-::|]\label{pref2}
  For all BREs |e| and all strings |xs|, if |[] <<-<< e >>| and |IsPrefix xs ∂[ e , x ]> | do not hold then
  neither does |IsPrefix (x :: xs) e|.
\end{Lemma}
\begin{proof}
  Immediate from the definition of |IsPrefix| and Theorem \ref{derivcomplete}.
\end{proof}

\begin{Lemma}[Lemma |¬IsSubstring|]\label{sub1}
  For all BREs |e|, if |IsPrefix [] e| does not hold then neither does |IsSubstring [] e|.
\end{Lemma}
\begin{proof}
  Immediate from the definitions of |IsPrefix| and |IsSubstring|.
\end{proof}

\begin{Lemma}[Lemma |¬IsSubstring-::|]
  For all strings |xs|, all symbols |x| and all BREs |e|, if |IsPrefix (x :: xs) e| 
  and |IsSubstring xs e| do not hold
  then neither does |IsSubstring (x :: xs) e|.
\end{Lemma}
\begin{proof}
  Immediate from the definitions of |IsPrefix| and |IsSubstring|.
\end{proof}

%format IsPrefixDec = "\F{IsPrefixDec}"
%format ∂-sound = "\F{∂-sound}"
%format cong = "\F{cong}"

Function |IsPrefixDec| decides if a given BRE |e| matches a prefix in
|xs| by induction on the structure of |xs|, using Lemmas \ref{pref1},
\ref{pref2}, decidable emptyness test |nuu[_]| and Theorem
\ref{derivsound}. Intuitively, |IsPrefixDec| first checks if current
RE |e| accepts the empty string. In this case, |[]| is returned as a
prefix. Otherwise, it verifies, for each symbol |x|, whether BRE |∂[ e , x ]>|
matches a prefix of the input string. If this is the case, a prefix
including |x| is built from a recursive call to |IsPrefixDec| or if no
prefix is matched a proof of such impossibility is constructed using
lemma |¬IsPrefix-::|.

\begin{spec}
  IsPrefixDec : forall xs e -> Dec (IsPrefix xs e)
  IsPrefixDec [] e with nuu[ e ]>
  IsPrefixDec [] e | yes p = yes (Prefix [] [] refl p)
  IsPrefixDec [] e | no ¬p = no (¬IsPrefix ¬p)
  IsPrefixDec (x :: xs) e with nuu[ e ]>
  IsPrefixDec (x :: xs) e | yes p = yes (Prefix [] (x :: xs) refl p)
  IsPrefixDec (x :: xs) e | no ¬p with IsPrefixDec xs (∂[ e , x ])
  IsPrefixDec (x :: xs) e | no ¬p | (yes (Prefix ys zs eq wit))
    = yes (Prefix (x :: ys) zs (cong (_::_ x) eq) (∂-sound wit))
  IsPrefixDec (x :: xs) e | no ¬pn | (no ¬p) 
    = no (¬IsPrefix-:: ¬pn ¬p)
\end{spec}

%format IsSubstringDec = "\F{IsSubstrDec}"

Function |IsSubstringDec| is also defined by induction on the
structure of the input string |e|, using |IsPrefixDec| to check
whether it is possible to match a prefix of |e|. In this case, a
substring is built from this prefix. If there's no such prefix, a
recursive call is made to check if there is a substring match,
returning such substring or a proof that it does not exist.

\begin{spec}
  IsSubstringDec : forall xs e -> Dec (IsSubstring xs e)
  IsSubstringDec [] e with nuu[ e ]>
  IsSubstringDec [] e | yes p = yes (Substring [] [] [] refl p)
  IsSubstringDec [] e | no ¬p = no (¬IsSubstring (¬IsPrefix ¬p))
  IsSubstringDec (x :: xs) e with IsPrefixDec (x :: xs) e
  IsSubstringDec (x :: xs) e | yes (Prefix ys zs eq wit)
    = yes (Substring [] ys zs eq wit)
  IsSubstringDec (x :: xs) e | no ¬p with IsSubstringDec xs e
  IsSubstringDec (x :: xs) e | no ¬p | (yes (Substring ys zs ws eq wit))
    = yes (Substring (x :: ys) zs ws (cong (_::_ x) eq) wit)
  IsSubstringDec (x :: xs) e | no ¬p₁ | (no ¬p)
    = no (¬IsSubstring-:: ¬p₁ ¬p)
\end{spec}

Previously defined functions for computing prefixes and substrings use BRE
derivatives. Definitions and properties of functions for prefix and substring computation
are given in folders \texttt{Prefix} and \texttt{Substring}, in the project's on-line
repository~\cite{regex-rep}.

\section{Implementation Details and Experiments}\label{sec:exp}

We include the formalized algorithm in a tool for RE parsing, developed by us, in the
style of GNU Grep~\cite{Grep}. We have built a simple parser
combinator library for parsing RE syntax, using the Agda Standard
Library and its support for calling Haskell functions through its
foreign function interface.

Experimentation with our tool, named verigrep, involved a comparison
of its performance with GNU Grep~\cite{Grep} (grep), Google regular
expression library re2~\cite{re2} and Haskell RE parsing algorithms
haskell-regexp, described in~\cite{Fischer2010}. We run RE parsing
experiments on a machine with a Intel Core I7 1.7 GHz, 8GB RAM running
Mac OS X 10.12.3; the results were collected and the median of several
test runs was computed.

We use the same experiments as those used in ~\cite{SulzmannL14};
these consist of parsing files containing thousands of occurrences of
symbol \texttt{a}, using the RE $(a + b + ab)^\star$; and parsing
files containing thousands of occurrences of \texttt{ab}, using the
same RE. Results are presented in Figures~\ref{fig:graph1}
and~\ref{fig:graph2}, respectively.

\begin{figure}[!ht]
    \includegraphics[width=0.45\textwidth]{as.png}
   \centering
   \caption{Results of experiment 1.}
   \label{fig:graph1}
\end{figure}

\begin{figure}[!ht]
    \includegraphics[width=0.45\textwidth]{abs.png}
   \centering
   \caption{Results of experiment 2.}
   \label{fig:graph2}
\end{figure}


Our tool behaves poorly when compared with all other options
considered. The cause of this inefficiency needs further
investigation, since the algorithm formalized uses POSIX 
disambiguation strategy, which avoid quotienting the result of derivative
operations w.r.t. ACUI axioms, as usual Brzozowski derivatives. We leave 
the proof that the formalized algorithm indeed produces POSIX parse trees 
for future work.

\section{Related Work}\label{sec:related}

\paragraph{Parsing with derivatives} Recently, derivative-based
parsing has received a lot of attention. Owens et al. were the first
to present a functional encoding of RE derivatives and use it to
parsing and DFA building. They use derivatives to build scanner
generators for ML and Scheme~\cite{Owens2009}; no formal proof of
correctness was presented.

Might et al.~\cite{Might2011} report on
the use of derivatives for parsing not only RLs but also context-free
ones. He uses derivatives to handle context-free grammars (CFG) and
develops an equational theory for compaction that allows for efficient
CFG parsing using derivatives. Implementation of derivatives for CFGs
are described by using the Racket programming
language~\cite{Felleisen2013}. However, Might et al. do not present
formal proofs related to the use of derivatives for CFGs.

Fischer et al.~describe an algorithm for RE-based parsing based on
weighted automata in Haskell~\cite{Fischer2010}.  The paper describes
the design evolution of such algorithm as a dialog between three
persons. Their implementation has a competitive performance when
compared with Google's RE library~\cite{re2}. This work also does not
consider formal proofs of RE parsing.

An algorithm for POSIX RE parsing is described
in~\cite{SulzmannL14}. The main idea of the article is to adapt
derivative parsing to construct parse trees incrementally to solve
both matching and submatching for REs. In order to improve the
efficiency of the proposed algorithm, Sulzmann et al. use a bit
encoded representation of RE parse trees. Textual proofs of
correctness of the proposed algorithm are presented in an appendix.

\paragraph{Certified parsing algorithms}. Certified algorithms for
parsing also received attention recently. Firsov et al.~describe a
certified algorithm for RE parsing by converting an input RE to an
equivalent NFA represented as a boolean matrix~\cite{FirsovU13}. A
matrix library based on some ``block'' operations~\cite{MacedoO13} is
developed and used Agda formalization of NFA-based parsing
{Norell2009}. Compared to our work, a NFA-based formalization requires
a lot more infrastructure (such as a Matrix library). No experiments
with the certified algorithm were reported.

Firsov describes an Agda formalization of a parsing algorithm that
deals with any CFG (CYK algorithm)~\cite{Firsov2014}. Bernardy
et al.~describe a formalization of another CFG parsing algorithm in
Agda~\cite{BernardyJ16}: Valiant's algorithm~\cite{Valiant1975}, which
reduces CFG parsing to boolean matrix multiplication. In both works,
no experiment with formalized parsing algorithms were reported.

A certified LR(1) CFG validator is described
in~\cite{Jourdan2012}. The formalized checking procedure verifies if
CFG and an automaton match. They proved soundness and completeness of
the validator in the Coq proof
assistant~\cite{Bertot2010}. Termination of the LR(1) automaton
interpreter is ensured by imposing a natural number bound on
allowed recursive calls.

Formalization of a parser combinator library was the subject of
Danielsson's work~\cite{Danielsson2010}. He built a library of parser
combinators using coinduction and provide correctness proofs of such
combinators.

Almeida et al.~\cite{AlmeidaMPS10} describe a Coq formalization of
partial derivatives and its equivalence with automata. Partial
derivatives were introduced by Antimirov~\cite{Antimirov91} as an
alternative to Brzozowski derivatives, since it avoids quotient
resulting REs with respect to ACUI axioms. Almeida et al. motivation
is to use such formalization as a basis for a decision procedure for
RE equivalence.

Ridge~\cite{Ridge2011} describes a formalization, in the HOL4 theorem
prover, of a combinator parsing library. A parser generator for such
combinators is described and a proof that generated parsers are sound
and complete is presented.  According to Ridge, preliminary results
shows that parsers built using his generator are faster than those
created by Happy parser generator~\cite{Happy}.

Ausaf et. al.~\cite{AusafDU16} describe a formalization, in
Isabelle/HOL~\cite{Nipkow02}, of the POSIX matching algorithm proposed
by Sulzmann et.al.~\cite{SulzmannL14}. They give a constructive
characterization of what a POSIX matching is and prove that such
matching is unique for a given RE and string. No experiments with the
verified algorithm are reported.


\section{Conclusion}\label{sec:conclusion}

We have given a complete formalization of a Bit-coded derivative-based 
parsing for REs in Agda. To the best of our knowledge, this is the first work
that presents a complete certification and that uses the certified
program to build a tool for RE-based search.

The formalized algorithm has 381 lines of code, organized in 2
modules. We have proven 18 theorems and lemmas to complete the
development. Most of them are immediate pattern matching functions
over inductive datatypes and were omitted from this text for brevity.
The verigrep tool has 3 parsing algorithms formalized in 1526 lines of code, 
distributed in 22 modules.

As future work, we intend to continue the development of verigrep by
certifying greedy and POSIX disambiguation strategies and finite state machine
based algorithms for parsing RE.

% \section*{References}
\bibliographystyle{ACM-Reference-Format}
\bibliography{main}

\end{document}

\end{document}
